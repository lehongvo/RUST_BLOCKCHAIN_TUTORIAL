{"$message_type":"diagnostic","message":"unused import: `std::fmt`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":102506,"byte_end":102514,"line_start":3926,"line_end":3926,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"use std::fmt;","highlight_start":5,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":63209,"byte_end":102515,"line_start":2351,"line_end":3926,"column_start":1,"column_end":14,"is_primary":true,"text":[{"text":"/// types in Rust, demonstrating both implicit and explicit type","highlight_start":1,"highlight_end":65},{"text":"/// parameter specification.","highlight_start":1,"highlight_end":29},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// Arguments:","highlight_start":1,"highlight_end":15},{"text":"///","highlight_start":1,"highlight_end":4},{"text":"/// * `_s`: Here's a breakdown of the parameters used in the code","highlight_start":1,"highlight_end":66},{"text":"/// snippet:","highlight_start":1,"highlight_end":13},{"text":"// struct A;          // Concrete type `A`.","highlight_start":1,"highlight_end":44},{"text":"// struct S(A);       // Concrete type `S`.","highlight_start":1,"highlight_end":44},{"text":"// struct SGen<T>(T); // Generic type `SGen`.","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn reg_fn(_s: S) {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn gen_spec_t(_s: SGen<A>) {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn gen_spec_i32(_s: SGen<i32>) {}","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn generic<T>(_s: SGen<T>) {}","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     // Using the non-generic functions","highlight_start":1,"highlight_end":42},{"text":"//     reg_fn(S(A));          // Concrete type.","highlight_start":1,"highlight_end":48},{"text":"//     gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.","highlight_start":1,"highlight_end":74},{"text":"//     gen_spec_i32(SGen(-1)); // Implicitly specified type parameter `i32`.","highlight_start":1,"highlight_end":77},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Explicitly specified type parameter `char` to `generic()`.","highlight_start":1,"highlight_end":69},{"text":"//     generic::<char>(SGen('a'));","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Implicitly specified type parameter `char` to `generic()`.","highlight_start":1,"highlight_end":69},{"text":"//     generic(SGen(12));","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// use std::ops::Add;","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // =================================================================","highlight_start":1,"highlight_end":72},{"text":"// fn sum<T>(value0: T, value1: T) -> T where T: Add<Output = T>{","highlight_start":1,"highlight_end":66},{"text":"//     let value = value0 + value1;","highlight_start":1,"highlight_end":36},{"text":"//     return value;","highlight_start":1,"highlight_end":21},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     assert_eq!(5, sum(2i8, 3i8));","highlight_start":1,"highlight_end":37},{"text":"//     assert_eq!(50, sum(20, 30));","highlight_start":1,"highlight_end":36},{"text":"//     assert_eq!(2.46, sum(1.23, 1.23));","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T","highlight_start":1,"highlight_end":12},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let integer = Point { x: 5, y: 10 };","highlight_start":1,"highlight_end":44},{"text":"//     println!(\"integer is {:?}\", integer);","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let float = Point { x: 1.0, y: 4.0 };","highlight_start":1,"highlight_end":45},{"text":"//     println!(\"float is {:?}\", float);","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// Modify this struct to make the code work","highlight_start":1,"highlight_end":44},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     // DON'T modify this code.","highlight_start":1,"highlight_end":34},{"text":"//     let p = Point{x: \"H!\".to_string(), y : \"hello\".to_string()};","highlight_start":1,"highlight_end":68},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// // Add generic for Val to make the code work, DON'T modify the code in `main`.","highlight_start":1,"highlight_end":82},{"text":"// struct Val<T> {","highlight_start":1,"highlight_end":19},{"text":"//     val: T,","highlight_start":1,"highlight_end":15},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T> Val<T> {","highlight_start":1,"highlight_end":20},{"text":"//     fn value(&self) -> &T {","highlight_start":1,"highlight_end":31},{"text":"//         &self.val","highlight_start":1,"highlight_end":21},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let x = Val{ val: 3.0 };","highlight_start":1,"highlight_end":32},{"text":"//     let y = Val{ val: \"hello\".to_string()};","highlight_start":1,"highlight_end":47},{"text":"//     println!(\"{}, {}\", x.value(), y.value());","highlight_start":1,"highlight_end":49},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// struct Point<T, U> {","highlight_start":1,"highlight_end":24},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: U,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T, U> Point<T, U> {","highlight_start":1,"highlight_end":28},{"text":"//     // Implement mixup to make it work, DON'T modify other code.","highlight_start":1,"highlight_end":68},{"text":"//     fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {","highlight_start":1,"highlight_end":65},{"text":"//         let point = Point {","highlight_start":1,"highlight_end":31},{"text":"//             x: self.x,","highlight_start":1,"highlight_end":26},{"text":"//             y: other.y","highlight_start":1,"highlight_end":26},{"text":"//         };","highlight_start":1,"highlight_end":14},{"text":"//         return point;","highlight_start":1,"highlight_end":25},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let p1 = Point { x: 5, y: 10 };","highlight_start":1,"highlight_end":39},{"text":"//     let p2 = Point { x: \"Hello\", y: '中'};","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let p3 = p1.mixup(p2);","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     assert_eq!(p3.x, 5);","highlight_start":1,"highlight_end":28},{"text":"//     assert_eq!(p3.y, '中');","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// struct Point<T, U> {","highlight_start":1,"highlight_end":24},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: U,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T, U> Point<T, U> {","highlight_start":1,"highlight_end":28},{"text":"//     // Implement mixup to make it work, DON'T modify other code.","highlight_start":1,"highlight_end":68},{"text":"//     fn mixup<K, L>(self, other: Point<K, L>) -> Point<T, L> {","highlight_start":1,"highlight_end":65},{"text":"//         let other_point = Point {","highlight_start":1,"highlight_end":37},{"text":"//             x: self.x,","highlight_start":1,"highlight_end":26},{"text":"//             y: other.y","highlight_start":1,"highlight_end":26},{"text":"//         };","highlight_start":1,"highlight_end":14},{"text":"//         return other_point;","highlight_start":1,"highlight_end":31},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let p1 = Point { x: 5, y: 10 };","highlight_start":1,"highlight_end":39},{"text":"//     let p2 = Point { x: \"Hello\", y: '中'};","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let p3 = p1.mixup(p2);","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     assert_eq!(p3.x, 5);","highlight_start":1,"highlight_end":28},{"text":"//     assert_eq!(p3.y, '中');","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// use std::{process::Output, ops::Add};","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // =================================================================","highlight_start":1,"highlight_end":72},{"text":"// // Implement the generic function below.","highlight_start":1,"highlight_end":44},{"text":"// fn sum<T>(value1: T, value2: T) -> T where T: Add<Output = T>{","highlight_start":1,"highlight_end":66},{"text":"//     let total_value = value1 + value2;","highlight_start":1,"highlight_end":42},{"text":"//     return total_value;","highlight_start":1,"highlight_end":27},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     assert_eq!(5, sum(2i8, 3i8));","highlight_start":1,"highlight_end":37},{"text":"//     assert_eq!(50, sum(20, 30));","highlight_start":1,"highlight_end":36},{"text":"//     assert_eq!(2.46, sum(1.23, 1.23));","highlight_start":1,"highlight_end":42},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// Implement struct Point to make it work.","highlight_start":1,"highlight_end":43},{"text":"// struct Point<T, K> {","highlight_start":1,"highlight_end":24},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: K","highlight_start":1,"highlight_end":12},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let integer = Point { x: 5, y: 10 };","highlight_start":1,"highlight_end":44},{"text":"//     let float = Point { x: 1.0, y: 4.0 };","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// Modify this struct to make the code work","highlight_start":1,"highlight_end":44},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     // DON'T modify this code.","highlight_start":1,"highlight_end":34},{"text":"//     let p = Point{x: \"hi\".to_string(), y : \"hello\".to_string()};","highlight_start":1,"highlight_end":68},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Modify this struct to make the code work","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Add generic for Val to make the code work, DON'T modify the code in `main`.","highlight_start":1,"highlight_end":79},{"text":"// struct Val<T> {","highlight_start":1,"highlight_end":19},{"text":"//     val: T,","highlight_start":1,"highlight_end":15},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T> Val<T> {","highlight_start":1,"highlight_end":20},{"text":"//     fn value(&self) -> &T {","highlight_start":1,"highlight_end":31},{"text":"//         &self.val","highlight_start":1,"highlight_end":21},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let x = Val{ val: 3.0 };","highlight_start":1,"highlight_end":32},{"text":"//     let y = Val{ val: \"hello\".to_string()};","highlight_start":1,"highlight_end":47},{"text":"//     println!(\"{}, {}\", x.value(), y.value());","highlight_start":1,"highlight_end":49},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// struct Point<T, U> {","highlight_start":1,"highlight_end":24},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: U,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T, U> Point<T, U> {","highlight_start":1,"highlight_end":28},{"text":"//     fn mixup<K, J>(self, other: Point<K, J>) -> Point<T, J> {","highlight_start":1,"highlight_end":65},{"text":"//         Point{","highlight_start":1,"highlight_end":18},{"text":"//             x: self.x,","highlight_start":1,"highlight_end":26},{"text":"//             y: other.y,","highlight_start":1,"highlight_end":27},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let p1 = Point { x: 5, y: 10 };","highlight_start":1,"highlight_end":39},{"text":"//     let p2 = Point { x: \"Hello\", y: '中'};","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let p3 = p1.mixup(p2);","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     assert_eq!(p3.x, 5);","highlight_start":1,"highlight_end":28},{"text":"//     assert_eq!(p3.y, '中');","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// Fix the errors to make the code work.","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Fix the errors to make the code work.","highlight_start":1,"highlight_end":41},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Point<f64> {","highlight_start":1,"highlight_end":21},{"text":"//     fn distance_from_origin(&self) -> f64 {","highlight_start":1,"highlight_end":47},{"text":"//         (self.x.powi(2) + self.y.powi(2)).sqrt()","highlight_start":1,"highlight_end":52},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let p: Point<f64> = Point{x: 5.0, y: 10.0};","highlight_start":1,"highlight_end":51},{"text":"//     println!(\"{}\",p.distance_from_origin());","highlight_start":1,"highlight_end":48},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// fn sum_array<const N: usize>(arr: [i32; N]) -> i32 {","highlight_start":1,"highlight_end":56},{"text":"//     let mut value = 0;","highlight_start":1,"highlight_end":26},{"text":"//     for element in &arr {","highlight_start":1,"highlight_end":29},{"text":"//         value += element;","highlight_start":1,"highlight_end":29},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"//     return value;","highlight_start":1,"highlight_end":21},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let array1 = [1, 2, 3, 4, 5];","highlight_start":1,"highlight_end":37},{"text":"//     let value = sum_array(array1);","highlight_start":1,"highlight_end":38},{"text":"//     println!(\"Value is {:?}\", value);","highlight_start":1,"highlight_end":41},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// fn sort_array<const N: usize>(mut arr: [i32; N]) -> [i32; N] {","highlight_start":1,"highlight_end":66},{"text":"//     arr.sort();","highlight_start":1,"highlight_end":19},{"text":"//     return arr;","highlight_start":1,"highlight_end":19},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     // Sử dụng hàm sắp xếp với mảng có kích thước cố định","highlight_start":1,"highlight_end":61},{"text":"//     let array = [5, 2, 8, 1, 7];","highlight_start":1,"highlight_end":36},{"text":"//     let sorted_array = sort_array(array);","highlight_start":1,"highlight_end":45},{"text":"//     println!(\"Sorted array: {:?}\", sorted_array);","highlight_start":1,"highlight_end":53},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// fn get_total<const N: usize>(values: [i32; N]) -> i32 {","highlight_start":1,"highlight_end":59},{"text":"//     let total_value = values.iter().sum();","highlight_start":1,"highlight_end":46},{"text":"//     return total_value;","highlight_start":1,"highlight_end":27},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let array = [5, 2, 8, 1, 7];","highlight_start":1,"highlight_end":36},{"text":"//     let sorted_array = get_total(array);","highlight_start":1,"highlight_end":44},{"text":"//     println!(\"Sorted array: {:?}\", sorted_array);","highlight_start":1,"highlight_end":53},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct ArrayPair<T, const N: usize> {","highlight_start":1,"highlight_end":41},{"text":"//     left: [T; N],","highlight_start":1,"highlight_end":21},{"text":"//     right:[T; N]","highlight_start":1,"highlight_end":20},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let value = ArrayPair {","highlight_start":1,"highlight_end":31},{"text":"//         left: [1, 2, 3],","highlight_start":1,"highlight_end":28},{"text":"//         right: [1, 2, 3],","highlight_start":1,"highlight_end":29},{"text":"//     };","highlight_start":1,"highlight_end":10},{"text":"//     println!(\"Value: {:?}\", value);","highlight_start":1,"highlight_end":39},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// fn foo<const N: usize>() {}","highlight_start":1,"highlight_end":31},{"text":"// fn bar<T, const M: usize>() {","highlight_start":1,"highlight_end":33},{"text":"//     foo::<M>;","highlight_start":1,"highlight_end":17},{"text":"//     foo::<2021>;","highlight_start":1,"highlight_end":20},{"text":"//     foo::<{20 * 100 + 20 * 10 + 1}>();","highlight_start":1,"highlight_end":42},{"text":"//     let _: [u8, m];","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// pub struct MinSlice<T, const N: usize> {","highlight_start":1,"highlight_end":44},{"text":"//     pub head: [T; N],","highlight_start":1,"highlight_end":25},{"text":"//     pub tail: [T]","highlight_start":1,"highlight_end":21},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let slice: &[u8] = b\"Hello, world\";","highlight_start":1,"highlight_end":43},{"text":"//     let reference = slice.get(6);","highlight_start":1,"highlight_end":37},{"text":"//     assert!(reference.is_some());","highlight_start":1,"highlight_end":37},{"text":"//     let slice: &[u8] = b\"Hello, world\";","highlight_start":1,"highlight_end":43},{"text":"//     let min_slice = MinSlice::<u8, 12>.","highlight_start":1,"highlight_end":43},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Array<T, const N: usize> {","highlight_start":1,"highlight_end":37},{"text":"//     data : [T; N]","highlight_start":1,"highlight_end":21},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let arrays = [","highlight_start":1,"highlight_end":22},{"text":"//         Array{","highlight_start":1,"highlight_end":18},{"text":"//             data: [1, 2, 3],","highlight_start":1,"highlight_end":32},{"text":"//         },","highlight_start":1,"highlight_end":14},{"text":"//         Array {","highlight_start":1,"highlight_end":19},{"text":"//             data: [1, 2, 3],","highlight_start":1,"highlight_end":32},{"text":"//         },","highlight_start":1,"highlight_end":14},{"text":"//         Array {","highlight_start":1,"highlight_end":19},{"text":"//             data: [1, 2, 4]","highlight_start":1,"highlight_end":31},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     ];","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success! is value {:?},\", arrays);","highlight_start":1,"highlight_end":52},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// Fill in the blanks to make it work.","highlight_start":1,"highlight_end":39},{"text":"// use std::fmt::Debug;","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn print_array<T: Debug, const N: usize>(arr:[T; N]) {","highlight_start":1,"highlight_end":58},{"text":"//     println!(\"{:?}\", arr);","highlight_start":1,"highlight_end":30},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let arr = [1, 2, 3];","highlight_start":1,"highlight_end":28},{"text":"//     print_array(arr);","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let arr = [\"hello\", \"world\"];","highlight_start":1,"highlight_end":37},{"text":"//     print_array(arr);","highlight_start":1,"highlight_end":25},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// #![allow(incomplete_features)]","highlight_start":1,"highlight_end":34},{"text":"// #![feature(generic_const_exprs)]","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn check_size<T>(val: T)","highlight_start":1,"highlight_end":28},{"text":"// where","highlight_start":1,"highlight_end":9},{"text":"//     Assert<{ core::mem::size_of::<T>() < 768 }>: IsTrue,","highlight_start":1,"highlight_end":60},{"text":"// {","highlight_start":1,"highlight_end":5},{"text":"//     //...","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // Fix the errors in main.","highlight_start":1,"highlight_end":30},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     check_size([0u8; 767]);","highlight_start":1,"highlight_end":31},{"text":"//     check_size([0i32; 191]);","highlight_start":1,"highlight_end":32},{"text":"//     check_size([\"hello你好\"; __]); // Size of &str ?","highlight_start":1,"highlight_end":54},{"text":"//     check_size([(); __].map(|_| \"hello你好\".to_string()));  // Size of String?","highlight_start":1,"highlight_end":80},{"text":"//     check_size(['中'; __]); // Size of char ?","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// pub enum Assert<const CHECK: bool> {}","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// pub trait IsTrue {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl IsTrue for Assert<true> {}","highlight_start":1,"highlight_end":35},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Sheep {","highlight_start":1,"highlight_end":18},{"text":"//     naked: bool,","highlight_start":1,"highlight_end":20},{"text":"//     name: String,","highlight_start":1,"highlight_end":21},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait Animal {","highlight_start":1,"highlight_end":18},{"text":"//     // Associated function signature; `Self` refers to the implementor type.","highlight_start":1,"highlight_end":80},{"text":"//     fn new(name: String) -> Self;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Method signatures; these will return a string.","highlight_start":1,"highlight_end":57},{"text":"//     fn name(&self) -> String;","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn noise(&self) -> String;","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Traits can provide default method definitions.","highlight_start":1,"highlight_end":57},{"text":"//     fn talk(&self) {","highlight_start":1,"highlight_end":24},{"text":"//         println!(\"{} says {}\", self.name(), self.noise());","highlight_start":1,"highlight_end":62},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Sheep {","highlight_start":1,"highlight_end":16},{"text":"//     fn is_naked(&self) -> bool {","highlight_start":1,"highlight_end":36},{"text":"//         self.naked","highlight_start":1,"highlight_end":22},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn un_naked(&mut self) {","highlight_start":1,"highlight_end":32},{"text":"//         self.naked = true;","highlight_start":1,"highlight_end":30},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn shear(&mut self) {","highlight_start":1,"highlight_end":29},{"text":"//         if self.is_naked() {","highlight_start":1,"highlight_end":32},{"text":"//             // Implementor methods can use the implementor's trait methods.","highlight_start":1,"highlight_end":79},{"text":"//             println!(\"{} is already naked...\", self.name());","highlight_start":1,"highlight_end":64},{"text":"//         } else {","highlight_start":1,"highlight_end":20},{"text":"//             println!(\"{} gets a haircut!\", self.name);","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//             self.naked = true;","highlight_start":1,"highlight_end":34},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // Implement the `Animal` trait for `Sheep`.","highlight_start":1,"highlight_end":48},{"text":"// impl Animal for Sheep {","highlight_start":1,"highlight_end":27},{"text":"//     // `Self` is the implementor type: `Sheep`.","highlight_start":1,"highlight_end":51},{"text":"//     fn new(name: String) -> Sheep {","highlight_start":1,"highlight_end":39},{"text":"//         Sheep {","highlight_start":1,"highlight_end":19},{"text":"//             name: name,","highlight_start":1,"highlight_end":27},{"text":"//             naked: false,","highlight_start":1,"highlight_end":29},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn name(&self) -> String {","highlight_start":1,"highlight_end":34},{"text":"//         self.name.clone()","highlight_start":1,"highlight_end":29},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn noise(&self) -> String {","highlight_start":1,"highlight_end":35},{"text":"//         if self.is_naked() {","highlight_start":1,"highlight_end":32},{"text":"//             \"baaaaah?\".to_string()","highlight_start":1,"highlight_end":38},{"text":"//         } else {","highlight_start":1,"highlight_end":20},{"text":"//             \"baaaaah!\".to_string()","highlight_start":1,"highlight_end":38},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Default trait methods can be overridden.","highlight_start":1,"highlight_end":51},{"text":"//     fn talk(&self) {","highlight_start":1,"highlight_end":24},{"text":"//         // For example, we can add some quiet contemplation.","highlight_start":1,"highlight_end":64},{"text":"//         println!(\"{} pauses briefly... {}\", self.name, self.noise());","highlight_start":1,"highlight_end":73},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     // Type annotation is necessary in this case.","highlight_start":1,"highlight_end":53},{"text":"//     let mut dolly: Sheep = Animal::new(\"Dolly\".to_string());","highlight_start":1,"highlight_end":64},{"text":"//     // TODO ^ Try removing the type annotations.","highlight_start":1,"highlight_end":52},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     dolly.talk();","highlight_start":1,"highlight_end":21},{"text":"//     dolly.shear();","highlight_start":1,"highlight_end":22},{"text":"//     dolly.talk();","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     dolly.un_naked();","highlight_start":1,"highlight_end":25},{"text":"//     dolly.shear();","highlight_start":1,"highlight_end":22},{"text":"//     dolly.noise();","highlight_start":1,"highlight_end":22},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait Hello {","highlight_start":1,"highlight_end":17},{"text":"//     fn say_hi(&self) -> String;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn say_something(&self) -> String;","highlight_start":1,"highlight_end":42},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Student {}","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Hello for Student {","highlight_start":1,"highlight_end":28},{"text":"//     fn say_hi(&self) -> String {","highlight_start":1,"highlight_end":36},{"text":"//         String::from(\"hi\")","highlight_start":1,"highlight_end":30},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"//     fn say_something(&self) -> String {","highlight_start":1,"highlight_end":43},{"text":"//         let value = format!(\"I'm a good student\");","highlight_start":1,"highlight_end":54},{"text":"//         return value;","highlight_start":1,"highlight_end":25},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Teacher {}","highlight_start":1,"highlight_end":21},{"text":"// impl Hello for Teacher {","highlight_start":1,"highlight_end":28},{"text":"//     fn say_hi(&self) -> String {","highlight_start":1,"highlight_end":36},{"text":"//         String::from(\"Hi, I'm your new teacher\")","highlight_start":1,"highlight_end":52},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"//     fn say_something(&self) -> String {","highlight_start":1,"highlight_end":43},{"text":"//         let value = format!(\"I'm not a bad teacher\");","highlight_start":1,"highlight_end":57},{"text":"//         return value;","highlight_start":1,"highlight_end":25},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let s = Student {};","highlight_start":1,"highlight_end":27},{"text":"//     assert_eq!(s.say_hi(), \"hi\");","highlight_start":1,"highlight_end":37},{"text":"//     assert_eq!(s.say_something(), \"I'm a good student\");","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let t = Teacher {};","highlight_start":1,"highlight_end":27},{"text":"//     assert_eq!(t.say_hi(), \"Hi, I'm your new teacher\");","highlight_start":1,"highlight_end":59},{"text":"//     assert_eq!(t.say_something(), \"I'm not a bad teacher\");","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(PartialEq, Debug, PartialOrd)]","highlight_start":1,"highlight_end":43},{"text":"// struct Centimeters(f64);","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Inches(i32);","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Inches {","highlight_start":1,"highlight_end":17},{"text":"//     fn to_centimeters(&self) -> Centimeters {","highlight_start":1,"highlight_end":49},{"text":"//         let &Inches(inches) = self;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//         Centimeters(inches as f64 * 2.54)","highlight_start":1,"highlight_end":45},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(PartialEq, Debug, PartialOrd)]","highlight_start":1,"highlight_end":43},{"text":"// struct Seconds(i32);","highlight_start":1,"highlight_end":24},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let _one_second = Seconds(1);","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"One second looks like: {:?}\", _one_second);","highlight_start":1,"highlight_end":61},{"text":"//     let _this_is_true = (_one_second == _one_second);","highlight_start":1,"highlight_end":57},{"text":"//     let _this_is_false = (_one_second > _one_second);","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let foot = Inches(12);","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"One foot equals {:?}\", foot);","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let meter = Centimeters(100.0);","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let cmp =","highlight_start":1,"highlight_end":17},{"text":"//         if foot.to_centimeters() < meter {","highlight_start":1,"highlight_end":46},{"text":"//             \"smaller\"","highlight_start":1,"highlight_end":25},{"text":"//         } else {","highlight_start":1,"highlight_end":20},{"text":"//             \"bigger\"","highlight_start":1,"highlight_end":24},{"text":"//         };","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"One foot is {} than one meter.\", cmp);","highlight_start":1,"highlight_end":56},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// use std::ops::{self, Mul};","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn multiply<T>(x: T, y: T) -> T where T: Mul<Output = T>{","highlight_start":1,"highlight_end":61},{"text":"//     let value = x * y;","highlight_start":1,"highlight_end":26},{"text":"//     return value;","highlight_start":1,"highlight_end":21},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     assert_eq!(6, multiply(2u8, 3u8));","highlight_start":1,"highlight_end":42},{"text":"//     assert_eq!(5.0, multiply(1.0, 5.0));","highlight_start":1,"highlight_end":44},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Fix the errors, DON'T modify the code in `main`.","highlight_start":1,"highlight_end":52},{"text":"// use std::ops;","highlight_start":1,"highlight_end":17},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug, PartialEq)]","highlight_start":1,"highlight_end":31},{"text":"// struct Foo;","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug, PartialEq)]","highlight_start":1,"highlight_end":31},{"text":"// struct Bar;","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug, PartialEq)]","highlight_start":1,"highlight_end":31},{"text":"// struct FooBar;","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug, PartialEq)]","highlight_start":1,"highlight_end":31},{"text":"// struct BarFoo;","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // The `std::ops::Add` trait is used to specify the functionality of `+`.","highlight_start":1,"highlight_end":77},{"text":"// // Here, we make `Add<Bar>` - the trait for addition with a RHS of type `Bar`.","highlight_start":1,"highlight_end":82},{"text":"// // The following block implements the operation: Foo + Bar = FooBar","highlight_start":1,"highlight_end":71},{"text":"// impl ops::Add<Bar> for Foo {","highlight_start":1,"highlight_end":32},{"text":"//     type Output = FooBar;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn add(self, _rhs: Bar) -> FooBar {","highlight_start":1,"highlight_end":43},{"text":"//         FooBar","highlight_start":1,"highlight_end":18},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl ops::Sub<Foo> for Bar {","highlight_start":1,"highlight_end":32},{"text":"//     type Output = BarFoo;","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn sub(self, _rhs: Foo) -> BarFoo {","highlight_start":1,"highlight_end":43},{"text":"//         BarFoo","highlight_start":1,"highlight_end":18},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     // DON'T modify the code below.","highlight_start":1,"highlight_end":39},{"text":"//     // You need to derive some trait for FooBar to make it comparable.","highlight_start":1,"highlight_end":74},{"text":"//     assert_eq!(Foo + Bar, FooBar);","highlight_start":1,"highlight_end":38},{"text":"//     assert_eq!(Foo - Bar, BarFoo);","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Implement `fn summary` to make the code work.","highlight_start":1,"highlight_end":49},{"text":"// Fix the errors without removing any code line","highlight_start":1,"highlight_end":49},{"text":"// pub trait Summary {","highlight_start":1,"highlight_end":23},{"text":"//     fn summarize(&self) -> String;","highlight_start":1,"highlight_end":38},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// pub struct Post {","highlight_start":1,"highlight_end":21},{"text":"//     title: String,","highlight_start":1,"highlight_end":22},{"text":"//     author: String,","highlight_start":1,"highlight_end":23},{"text":"//     content: String,","highlight_start":1,"highlight_end":24},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Summary for Post {","highlight_start":1,"highlight_end":27},{"text":"//     fn summarize(&self) -> String {","highlight_start":1,"highlight_end":39},{"text":"//         format!(\"The author of post {} is {}\", self.title, self.author)","highlight_start":1,"highlight_end":75},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// pub struct Weibo {","highlight_start":1,"highlight_end":22},{"text":"//     username: String,","highlight_start":1,"highlight_end":25},{"text":"//     content: String,","highlight_start":1,"highlight_end":24},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Summary for Weibo {","highlight_start":1,"highlight_end":28},{"text":"//     fn summarize(&self) -> String {","highlight_start":1,"highlight_end":39},{"text":"//         format!(\"{} published a weibo {}\", self.username, self.content)","highlight_start":1,"highlight_end":75},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let post = Post {","highlight_start":1,"highlight_end":25},{"text":"//         title: \"Popular Rust\".to_string(),","highlight_start":1,"highlight_end":46},{"text":"//         author: \"Sunface\".to_string(),","highlight_start":1,"highlight_end":42},{"text":"//         content: \"Rust is awesome!\".to_string(),","highlight_start":1,"highlight_end":52},{"text":"//     };","highlight_start":1,"highlight_end":10},{"text":"//     let weibo = Weibo {","highlight_start":1,"highlight_end":27},{"text":"//         username: \"sunface\".to_string(),","highlight_start":1,"highlight_end":44},{"text":"//         content: \"Weibo seems to be worse than Tweet\".to_string(),","highlight_start":1,"highlight_end":70},{"text":"//     };","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     post.summarize();","highlight_start":1,"highlight_end":25},{"text":"//     weibo.summarize();","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"{:?}\", post);","highlight_start":1,"highlight_end":31},{"text":"//     println!(\"{:?}\", weibo);","highlight_start":1,"highlight_end":32},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// struct Sheep {}","highlight_start":1,"highlight_end":19},{"text":"// struct Cow {}","highlight_start":1,"highlight_end":17},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait Animal {","highlight_start":1,"highlight_end":18},{"text":"//     fn noise(&self) -> String;","highlight_start":1,"highlight_end":34},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Animal for Sheep {","highlight_start":1,"highlight_end":27},{"text":"//     fn noise(&self) -> String {","highlight_start":1,"highlight_end":35},{"text":"//         \"baaaaah!\".to_string()","highlight_start":1,"highlight_end":34},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Animal for Cow {","highlight_start":1,"highlight_end":25},{"text":"//     fn noise(&self) -> String {","highlight_start":1,"highlight_end":35},{"text":"//         \"moooooo!\".to_string()","highlight_start":1,"highlight_end":34},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // Returns some struct that implements Animal, but we don't know which one at compile time.","highlight_start":1,"highlight_end":95},{"text":"// // FIX the errors here, you can make a fake random, or you can use trait object.","highlight_start":1,"highlight_end":84},{"text":"// fn random_animal(random_number: f64) -> Box<dyn Animal> {","highlight_start":1,"highlight_end":61},{"text":"//     if random_number < 0.5 {","highlight_start":1,"highlight_end":32},{"text":"//         Box::new(Sheep {})","highlight_start":1,"highlight_end":30},{"text":"//     } else {","highlight_start":1,"highlight_end":16},{"text":"//         Box::new(Cow {})","highlight_start":1,"highlight_end":28},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let random_number = 0.234;","highlight_start":1,"highlight_end":34},{"text":"//     let animal = random_animal(random_number);","highlight_start":1,"highlight_end":50},{"text":"//     println!(\"You've randomly chosen an animal, and it says {}\", animal.noise());","highlight_start":1,"highlight_end":85},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// use std::{process::Output, ops::Add};","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     assert_eq!(sum(1, 2), 3);","highlight_start":1,"highlight_end":33},{"text":"//     println!(\"All ok\");","highlight_start":1,"highlight_end":27},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn sum<T>(x: T, y: T) -> T  where T: Add<Output = T>{","highlight_start":1,"highlight_end":57},{"text":"//     x + y","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// FIX the errors.","highlight_start":1,"highlight_end":19},{"text":"// #[derive(Debug, PartialEq, PartialOrd)]","highlight_start":1,"highlight_end":43},{"text":"// struct Pair<T> {","highlight_start":1,"highlight_end":20},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T> Pair<T> {","highlight_start":1,"highlight_end":21},{"text":"//     fn new(x: T, y: T) -> Self {","highlight_start":1,"highlight_end":36},{"text":"//         Self {","highlight_start":1,"highlight_end":18},{"text":"//             x,","highlight_start":1,"highlight_end":18},{"text":"//             y,","highlight_start":1,"highlight_end":18},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T: std::fmt::Debug + PartialOrd> Pair<T> {","highlight_start":1,"highlight_end":51},{"text":"//     fn cmp_display(&self) {","highlight_start":1,"highlight_end":31},{"text":"//         if self.x >= self.y {","highlight_start":1,"highlight_end":33},{"text":"//             println!(\"The largest member is x = {:?}\", self.x);","highlight_start":1,"highlight_end":67},{"text":"//         } else {","highlight_start":1,"highlight_end":20},{"text":"//             println!(\"The largest member is y = {:?}\", self.y);","highlight_start":1,"highlight_end":67},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug, PartialEq, PartialOrd)]","highlight_start":1,"highlight_end":43},{"text":"// struct Unit(i32);","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let pair = Pair{","highlight_start":1,"highlight_end":24},{"text":"//         x: Unit(1),","highlight_start":1,"highlight_end":23},{"text":"//         y: Unit(3)","highlight_start":1,"highlight_end":22},{"text":"//     };","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     pair.cmp_display();","highlight_start":1,"highlight_end":27},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Fill in the blanks to make it work","highlight_start":1,"highlight_end":38},{"text":"// fn example1() {","highlight_start":1,"highlight_end":19},{"text":"//     // `T: Trait` is the commonly used way.","highlight_start":1,"highlight_end":47},{"text":"//     // `T: Fn(u32) -> u32` specifies that we can only pass a closure to `T`.","highlight_start":1,"highlight_end":80},{"text":"//     struct Cacher<T: Fn(u32) -> u32> {","highlight_start":1,"highlight_end":42},{"text":"//         calculation: T,","highlight_start":1,"highlight_end":27},{"text":"//         value: Option<u32>,","highlight_start":1,"highlight_end":31},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     impl<T: Fn(u32) -> u32> Cacher<T> {","highlight_start":1,"highlight_end":43},{"text":"//         fn new(calculation: T) -> Cacher<T> {","highlight_start":1,"highlight_end":49},{"text":"//             Cacher {","highlight_start":1,"highlight_end":24},{"text":"//                 calculation,","highlight_start":1,"highlight_end":32},{"text":"//                 value: None,","highlight_start":1,"highlight_end":32},{"text":"//             }","highlight_start":1,"highlight_end":17},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//         fn value(&mut self, arg: u32) -> u32 {","highlight_start":1,"highlight_end":50},{"text":"//             match self.value {","highlight_start":1,"highlight_end":34},{"text":"//                 Some(v) => v,","highlight_start":1,"highlight_end":33},{"text":"//                 None => {","highlight_start":1,"highlight_end":29},{"text":"//                     let v = (self.calculation)(arg);","highlight_start":1,"highlight_end":56},{"text":"//                     self.value = Some(v);","highlight_start":1,"highlight_end":45},{"text":"//                     v","highlight_start":1,"highlight_end":25},{"text":"//                 }","highlight_start":1,"highlight_end":21},{"text":"//             }","highlight_start":1,"highlight_end":17},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let mut cacher = Cacher::new(|x| x + 1);","highlight_start":1,"highlight_end":48},{"text":"//     assert_eq!(cacher.value(10), __);","highlight_start":1,"highlight_end":41},{"text":"//     assert_eq!(cacher.value(15), __);","highlight_start":1,"highlight_end":41},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn example2() {","highlight_start":1,"highlight_end":19},{"text":"//     // We can also use `where` to construct `T`","highlight_start":1,"highlight_end":51},{"text":"//     struct Cacher<T>","highlight_start":1,"highlight_end":24},{"text":"//     where","highlight_start":1,"highlight_end":13},{"text":"//         T: Fn(u32) -> u32,","highlight_start":1,"highlight_end":30},{"text":"//     {","highlight_start":1,"highlight_end":9},{"text":"//         calculation: T,","highlight_start":1,"highlight_end":27},{"text":"//         value: Option<u32>,","highlight_start":1,"highlight_end":31},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     impl<T> Cacher<T>","highlight_start":1,"highlight_end":25},{"text":"//     where","highlight_start":1,"highlight_end":13},{"text":"//         T: Fn(u32) -> u32,","highlight_start":1,"highlight_end":30},{"text":"//     {","highlight_start":1,"highlight_end":9},{"text":"//         fn new(calculation: T) -> Cacher<T> {","highlight_start":1,"highlight_end":49},{"text":"//             Cacher {","highlight_start":1,"highlight_end":24},{"text":"//                 calculation,","highlight_start":1,"highlight_end":32},{"text":"//                 value: None,","highlight_start":1,"highlight_end":32},{"text":"//             }","highlight_start":1,"highlight_end":17},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//         fn value(&mut self, arg: u32) -> u32 {","highlight_start":1,"highlight_end":50},{"text":"//             match self.value {","highlight_start":1,"highlight_end":34},{"text":"//                 Some(v) => v,","highlight_start":1,"highlight_end":33},{"text":"//                 None => {","highlight_start":1,"highlight_end":29},{"text":"//                     let v = (self.calculation)(arg);","highlight_start":1,"highlight_end":56},{"text":"//                     self.value = Some(v);","highlight_start":1,"highlight_end":45},{"text":"//                     v","highlight_start":1,"highlight_end":25},{"text":"//                 }","highlight_start":1,"highlight_end":21},{"text":"//             }","highlight_start":1,"highlight_end":17},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let mut cacher = Cacher::new(|x| x + 1);","highlight_start":1,"highlight_end":48},{"text":"//     assert_eq!(cacher.value(20), __);","highlight_start":1,"highlight_end":41},{"text":"//     assert_eq!(cacher.value(25), __);","highlight_start":1,"highlight_end":41},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     example1();","highlight_start":1,"highlight_end":19},{"text":"//     example2();","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// fn example_test1() {","highlight_start":1,"highlight_end":24},{"text":"//     struct Cached<T: Fn(u32) -> u32> {","highlight_start":1,"highlight_end":42},{"text":"//         calculate: T,","highlight_start":1,"highlight_end":25},{"text":"//         value: Option<u32>","highlight_start":1,"highlight_end":30},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     impl <T: Fn(u32) -> u32> Cached<T> {","highlight_start":1,"highlight_end":44},{"text":"//         fn new(calculate: T) -> Cached<T> {","highlight_start":1,"highlight_end":47},{"text":"//             let new_cacher = Cached {","highlight_start":1,"highlight_end":41},{"text":"//                 calculate: calculate,","highlight_start":1,"highlight_end":41},{"text":"//                 value: None","highlight_start":1,"highlight_end":31},{"text":"//             };","highlight_start":1,"highlight_end":18},{"text":"//             return new_cacher;","highlight_start":1,"highlight_end":34},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//         fn value(&mut self, arg: u32) -> u32 {","highlight_start":1,"highlight_end":50},{"text":"//             match self.value {","highlight_start":1,"highlight_end":34},{"text":"//                 Some(v) => v,","highlight_start":1,"highlight_end":33},{"text":"//                 None => {","highlight_start":1,"highlight_end":29},{"text":"//                     let v = (self.calculate)(arg);","highlight_start":1,"highlight_end":54},{"text":"//                     self.value = Some(v);","highlight_start":1,"highlight_end":45},{"text":"//                     v","highlight_start":1,"highlight_end":25},{"text":"//                 }","highlight_start":1,"highlight_end":21},{"text":"//             }","highlight_start":1,"highlight_end":17},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"//     let mut cached = Cached::new(|x| x + 1);","highlight_start":1,"highlight_end":48},{"text":"//     assert_eq!(cached.value(10), 11);","highlight_start":1,"highlight_end":41},{"text":"//     assert_eq!(cached.value(15), 15);","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     example_test1();","highlight_start":1,"highlight_end":24},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// trait Printable {","highlight_start":1,"highlight_end":21},{"text":"//     fn print(&self);","highlight_start":1,"highlight_end":24},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// struct Dog;","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Printable for Dog {","highlight_start":1,"highlight_end":28},{"text":"//     fn print(&self) {","highlight_start":1,"highlight_end":25},{"text":"//         println!(\"This a dog\");","highlight_start":1,"highlight_end":35},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn print_trait_object(printable: &dyn Printable) {","highlight_start":1,"highlight_end":54},{"text":"//     printable.print();","highlight_start":1,"highlight_end":26},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let dog = Dog;","highlight_start":1,"highlight_end":22},{"text":"//     print_trait_object(&dog);","highlight_start":1,"highlight_end":33},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// trait Bird {","highlight_start":1,"highlight_end":16},{"text":"//     fn quack(&self) -> String;","highlight_start":1,"highlight_end":34},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Duck;","highlight_start":1,"highlight_end":16},{"text":"// impl Duck {","highlight_start":1,"highlight_end":15},{"text":"//     fn swim(&self) {","highlight_start":1,"highlight_end":24},{"text":"//         println!(\"Look, the duck is swimming\")","highlight_start":1,"highlight_end":50},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Swan;","highlight_start":1,"highlight_end":16},{"text":"// impl Swan {","highlight_start":1,"highlight_end":15},{"text":"//     fn fly(&self) {","highlight_start":1,"highlight_end":23},{"text":"//         println!(\"Look, the duck.. oh sorry, the swan is flying\")","highlight_start":1,"highlight_end":69},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Bird for Duck {","highlight_start":1,"highlight_end":24},{"text":"//     fn quack(&self) -> String{","highlight_start":1,"highlight_end":34},{"text":"//         \"duck duck\".to_string()","highlight_start":1,"highlight_end":35},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Bird for Swan {","highlight_start":1,"highlight_end":24},{"text":"//     fn quack(&self) -> String{","highlight_start":1,"highlight_end":34},{"text":"//         \"swan swan\".to_string()","highlight_start":1,"highlight_end":35},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn hatch_a_bird(id: i32) -> Box<dyn Bird> {","highlight_start":1,"highlight_end":47},{"text":"//     match id % 2 {","highlight_start":1,"highlight_end":22},{"text":"//         0 => Box::new(Duck),","highlight_start":1,"highlight_end":32},{"text":"//         _ => {","highlight_start":1,"highlight_end":18},{"text":"//             println!(\"OK\");","highlight_start":1,"highlight_end":31},{"text":"//             Box::new(Swan)","highlight_start":1,"highlight_end":30},{"text":"//         },","highlight_start":1,"highlight_end":14},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let duck = Duck {};","highlight_start":1,"highlight_end":27},{"text":"//     duck.swim();","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let bird: Box<dyn Bird> = hatch_a_bird(2);","highlight_start":1,"highlight_end":50},{"text":"//     assert_eq!(bird.quack(), \"duck duck\");","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let swan = hatch_a_bird(1);","highlight_start":1,"highlight_end":35},{"text":"//     assert_eq!(swan.quack(), \"swan swan\");","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// trait Bird {","highlight_start":1,"highlight_end":16},{"text":"//     fn quack(&self);","highlight_start":1,"highlight_end":24},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// struct Duck;","highlight_start":1,"highlight_end":16},{"text":"// impl Duck {","highlight_start":1,"highlight_end":15},{"text":"//     fn fly(&self) {","highlight_start":1,"highlight_end":23},{"text":"//         println!(\"Look, the duck is flying\")","highlight_start":1,"highlight_end":48},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// struct Swan;","highlight_start":1,"highlight_end":16},{"text":"// impl Swan {","highlight_start":1,"highlight_end":15},{"text":"//     fn fly(&self) {","highlight_start":1,"highlight_end":23},{"text":"//         println!(\"Look, the duck.. oh sorry, the swan is flying\")","highlight_start":1,"highlight_end":69},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Bird for Duck {","highlight_start":1,"highlight_end":24},{"text":"//     fn quack(&self) {","highlight_start":1,"highlight_end":25},{"text":"//         println!(\"{}\", \"duck duck\");","highlight_start":1,"highlight_end":40},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Bird for Swan {","highlight_start":1,"highlight_end":24},{"text":"//     fn quack(&self) {","highlight_start":1,"highlight_end":25},{"text":"//         println!(\"{}\", \"swan swan\");","highlight_start":1,"highlight_end":40},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     // FILL in the blank to make the code work.","highlight_start":1,"highlight_end":51},{"text":"//     let birds: Vec<Box<dyn Bird>> = vec![Box::new(Duck), Box::new(Swan)];","highlight_start":1,"highlight_end":77},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     for bird in birds {","highlight_start":1,"highlight_end":27},{"text":"//         bird.quack();","highlight_start":1,"highlight_end":25},{"text":"//         // When duck and swan turn into Birds, they all forgot how to fly, only remember how to quack.","highlight_start":1,"highlight_end":106},{"text":"//         // So, the code below will cause an error.","highlight_start":1,"highlight_end":54},{"text":"//         // bird.fly();","highlight_start":1,"highlight_end":26},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// FILL in the blanks.","highlight_start":1,"highlight_end":23},{"text":"// trait Draw {","highlight_start":1,"highlight_end":16},{"text":"//     fn draw(&self) -> String;","highlight_start":1,"highlight_end":33},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Draw for u8 {","highlight_start":1,"highlight_end":22},{"text":"//     fn draw(&self) -> String {","highlight_start":1,"highlight_end":34},{"text":"//         format!(\"u8: {}\", *self)","highlight_start":1,"highlight_end":36},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Draw for f64 {","highlight_start":1,"highlight_end":23},{"text":"//     fn draw(&self) -> String {","highlight_start":1,"highlight_end":34},{"text":"//         format!(\"f64: {}\", *self)","highlight_start":1,"highlight_end":37},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let x = 1.1f64;","highlight_start":1,"highlight_end":23},{"text":"//     let y = 8u8;","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Draw x.","highlight_start":1,"highlight_end":18},{"text":"//     draw_with_box(Box::new(x));","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Draw y.","highlight_start":1,"highlight_end":18},{"text":"//     draw_with_ref(&y);","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn draw_with_box(x: Box<dyn Draw>) {","highlight_start":1,"highlight_end":40},{"text":"//     x.draw();","highlight_start":1,"highlight_end":17},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn draw_with_ref(x: &dyn Draw) {","highlight_start":1,"highlight_end":36},{"text":"//     x.draw();","highlight_start":1,"highlight_end":17},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// trait Foo {","highlight_start":1,"highlight_end":15},{"text":"//     fn method(&self) -> String;","highlight_start":1,"highlight_end":35},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Foo for u8 {","highlight_start":1,"highlight_end":21},{"text":"//     fn method(&self) -> String { format!(\"u8: {}\", *self) }","highlight_start":1,"highlight_end":63},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Foo for String {","highlight_start":1,"highlight_end":25},{"text":"//     fn method(&self) -> String { format!(\"string: {}\", *self) }","highlight_start":1,"highlight_end":67},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // IMPLEMENT below with generics.","highlight_start":1,"highlight_end":37},{"text":"// fn static_dispatch<T : Foo>(value: T) {","highlight_start":1,"highlight_end":43},{"text":"//     println!(\"{}\", value.method());","highlight_start":1,"highlight_end":39},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // Implement below with trait objects.","highlight_start":1,"highlight_end":42},{"text":"// fn dynamic_dispatch(value: &dyn Foo) {","highlight_start":1,"highlight_end":42},{"text":"//     println!(\"{}\", value.method());","highlight_start":1,"highlight_end":39},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let x = 5u8;","highlight_start":1,"highlight_end":20},{"text":"//     let y = \"Hello\".to_string();","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     static_dispatch(x);","highlight_start":1,"highlight_end":27},{"text":"//     dynamic_dispatch(&y);","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Use at least two approaches to make it work.","highlight_start":1,"highlight_end":48},{"text":"// DON'T add/remove any code line.","highlight_start":1,"highlight_end":35},{"text":"// trait MyTrait {","highlight_start":1,"highlight_end":19},{"text":"//     fn f(&self) -> Self;","highlight_start":1,"highlight_end":28},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl MyTrait for u32 {","highlight_start":1,"highlight_end":26},{"text":"//     fn f(&self) -> Self { 42u32 }","highlight_start":1,"highlight_end":37},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl MyTrait for String {","highlight_start":1,"highlight_end":29},{"text":"//     fn f(&self) -> Self { self.clone() }","highlight_start":1,"highlight_end":44},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn my_function<T: MyTrait>(x: T) {","highlight_start":1,"highlight_end":38},{"text":"//     println!(\"Print some thing\");","highlight_start":1,"highlight_end":37},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     my_function(21);","highlight_start":1,"highlight_end":24},{"text":"//     my_function(\"Je\".to_string());","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Use at least two approaches to make it work.","highlight_start":1,"highlight_end":48},{"text":"// DON'T add/remove any code line.","highlight_start":1,"highlight_end":35},{"text":"// trait MyTrait {","highlight_start":1,"highlight_end":19},{"text":"//     fn f(&self) -> Self;","highlight_start":1,"highlight_end":28},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl MyTrait for u32 {","highlight_start":1,"highlight_end":26},{"text":"//     fn f(&self) -> Self { 42 }","highlight_start":1,"highlight_end":34},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl MyTrait for String {","highlight_start":1,"highlight_end":29},{"text":"//     fn f(&self) -> Self { self.clone() }","highlight_start":1,"highlight_end":44},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn my_function<T: MyTrait>(x: T)  {","highlight_start":1,"highlight_end":39},{"text":"//     println!(\"Print some thing\");","highlight_start":1,"highlight_end":37},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     my_function(21);","highlight_start":1,"highlight_end":24},{"text":"//     my_function(\"Je\".to_string());","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// Use at least two approaches to make it work.","highlight_start":1,"highlight_end":48},{"text":"// DON'T add/remove any code line.","highlight_start":1,"highlight_end":35},{"text":"// trait MyTrait {","highlight_start":1,"highlight_end":19},{"text":"//     fn f(&self) -> Box<dyn MyTrait>;","highlight_start":1,"highlight_end":40},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl MyTrait for u32 {","highlight_start":1,"highlight_end":26},{"text":"//     fn f(&self) -> Box<dyn MyTrait> { Box::new(342) }","highlight_start":1,"highlight_end":57},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl MyTrait for String {","highlight_start":1,"highlight_end":29},{"text":"//     fn f(&self) -> Box<dyn MyTrait> { Box::new(self.clone()) }","highlight_start":1,"highlight_end":66},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn my_function(x: Box<dyn MyTrait>)  {","highlight_start":1,"highlight_end":42},{"text":"//     println!(\"Do some thing\");","highlight_start":1,"highlight_end":34},{"text":"//     // x.f()","highlight_start":1,"highlight_end":16},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     my_function(Box::new(13_u32));","highlight_start":1,"highlight_end":38},{"text":"//     my_function(Box::new(String::from(\"abc\")));","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// struct Container(i32, i32);","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait Contains<A, B> {","highlight_start":1,"highlight_end":26},{"text":"//     fn contains(&self, _: &A, _: &B) -> bool;","highlight_start":1,"highlight_end":49},{"text":"//     fn first(&self) -> i32;","highlight_start":1,"highlight_end":31},{"text":"//     fn last(&self) -> i32;","highlight_start":1,"highlight_end":30},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Contains<i32, i32> for Container {","highlight_start":1,"highlight_end":43},{"text":"//     fn contains(&self, number_1: &i32, number_2: &i32) -> bool {","highlight_start":1,"highlight_end":68},{"text":"//         (&self.0 == number_1) && (&self.1 == number_2)","highlight_start":1,"highlight_end":58},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"//     fn first(&self) -> i32 { self.0 }","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn last(&self) -> i32 { self.1 }","highlight_start":1,"highlight_end":40},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn difference<A, B, C: Contains<A, B>>(container: &C) -> i32 {","highlight_start":1,"highlight_end":66},{"text":"//     container.last() - container.first()","highlight_start":1,"highlight_end":44},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let number_1 = 3;","highlight_start":1,"highlight_end":25},{"text":"//     let number_2 = 10;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let container = Container(number_1, number_2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Does container contain {} and {}: {}\",","highlight_start":1,"highlight_end":56},{"text":"//         &number_1, &number_2,","highlight_start":1,"highlight_end":33},{"text":"//         container.contains(&number_1, &number_2));","highlight_start":1,"highlight_end":54},{"text":"//     println!(\"First number: {}\", container.first());","highlight_start":1,"highlight_end":56},{"text":"//     println!(\"Last number: {}\", container.last());","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"The difference is: {}\", difference(&container));","highlight_start":1,"highlight_end":66},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// use std::ops::Sub;","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // =================================================================","highlight_start":1,"highlight_end":72},{"text":"// #[derive(Debug, PartialEq)]","highlight_start":1,"highlight_end":31},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T","highlight_start":1,"highlight_end":12},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// impl <T: Sub<Output = T>> Sub for Point<T> {","highlight_start":1,"highlight_end":48},{"text":"//     type Output = Self;","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn sub(self, rhs: Self) -> Self::Output {","highlight_start":1,"highlight_end":49},{"text":"//         Point {","highlight_start":1,"highlight_end":19},{"text":"//             x: self.x - rhs.x,","highlight_start":1,"highlight_end":34},{"text":"//             y: self.y - rhs.y,","highlight_start":1,"highlight_end":34},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// fn main(){","highlight_start":1,"highlight_end":14},{"text":"//     let point = Point{x: 0, y:10} - Point{x: 0, y:11};","highlight_start":1,"highlight_end":58},{"text":"//     println!(\"Value is {:?}\", point);","highlight_start":1,"highlight_end":41},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// #[derive(Debug, PartialEq)]","highlight_start":1,"highlight_end":31},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T","highlight_start":1,"highlight_end":12},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl <T: Mul<Output = T>> Mul for Point<T> {","highlight_start":1,"highlight_end":48},{"text":"//     type Output = Self;","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn mul(self, rhs: Self) -> Self::Output {","highlight_start":1,"highlight_end":49},{"text":"//         let point = Point {","highlight_start":1,"highlight_end":31},{"text":"//             x: self.x * rhs.x,","highlight_start":1,"highlight_end":34},{"text":"//             y: self.y * rhs.y","highlight_start":1,"highlight_end":33},{"text":"//         };","highlight_start":1,"highlight_end":14},{"text":"//         return point;","highlight_start":1,"highlight_end":25},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let point = Point{x: 3, y: 10} * Point{x: 4, y: 9};","highlight_start":1,"highlight_end":59},{"text":"//     println!(\"Value is: {:?}\", point);","highlight_start":1,"highlight_end":42},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// use std::ops::{Add, Mul};","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl<T: Add<Output = T>> Add for Point<T> {","highlight_start":1,"highlight_end":47},{"text":"//     type Output = Self;","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     fn add(self, rhs: Self) -> Self::Output {","highlight_start":1,"highlight_end":49},{"text":"//         let new_point = Point {","highlight_start":1,"highlight_end":35},{"text":"//             x: self.x + rhs.x,","highlight_start":1,"highlight_end":34},{"text":"//             y:  self.y + rhs.y","highlight_start":1,"highlight_end":34},{"text":"//         };","highlight_start":1,"highlight_end":14},{"text":"//         return new_point;","highlight_start":1,"highlight_end":29},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let p1 = Point {x: 1, y: 2};","highlight_start":1,"highlight_end":36},{"text":"//     let p2 = Point {x: 3, y: 43};","highlight_start":1,"highlight_end":37},{"text":"//     let p2 = p1 + p2;","highlight_start":1,"highlight_end":25},{"text":"//     println!(\"Value is {:?}\", p2);","highlight_start":1,"highlight_end":38},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Container(i32, i32);","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait Contains<A, B> {","highlight_start":1,"highlight_end":26},{"text":"//     fn contains(&self, number_1: &A, number_2: &B) -> bool;","highlight_start":1,"highlight_end":63},{"text":"//     fn first(&self) -> i32;","highlight_start":1,"highlight_end":31},{"text":"//     fn last(&self) -> i32;","highlight_start":1,"highlight_end":30},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Contains<i32, i32> for Container {","highlight_start":1,"highlight_end":43},{"text":"//     fn contains(&self, number_1: &i32, number_2: &i32) -> bool {","highlight_start":1,"highlight_end":68},{"text":"//         let value = (&self.0 == number_1) && (&self.1 == number_2);","highlight_start":1,"highlight_end":71},{"text":"//         return value;","highlight_start":1,"highlight_end":25},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"//     // Grab the first number.","highlight_start":1,"highlight_end":33},{"text":"//     fn first(&self) -> i32 {","highlight_start":1,"highlight_end":32},{"text":"//         self.0","highlight_start":1,"highlight_end":18},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // Grab the last number.","highlight_start":1,"highlight_end":32},{"text":"//     fn last(&self) -> i32 {","highlight_start":1,"highlight_end":31},{"text":"//         self.1","highlight_start":1,"highlight_end":18},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn difference<A, B, C: Contains<A, B>>(container: &C) -> i32 {","highlight_start":1,"highlight_end":66},{"text":"//     container.last() - container.first()","highlight_start":1,"highlight_end":44},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let number_1 = 3;","highlight_start":1,"highlight_end":25},{"text":"//     let number_2 = 10;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     let container = Container(number_1, number_2);","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(","highlight_start":1,"highlight_end":17},{"text":"//         \"Does container contain {} and {}: {}\",","highlight_start":1,"highlight_end":51},{"text":"//         &number_1,","highlight_start":1,"highlight_end":22},{"text":"//         &number_2,","highlight_start":1,"highlight_end":22},{"text":"//         container.contains(&number_1, &number_2)","highlight_start":1,"highlight_end":52},{"text":"//     );","highlight_start":1,"highlight_end":10},{"text":"//     println!(\"First number: {}\", container.first());","highlight_start":1,"highlight_end":56},{"text":"//     println!(\"Last number: {}\", container.last());","highlight_start":1,"highlight_end":54},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"The difference is: {}\", difference(&container));","highlight_start":1,"highlight_end":66},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// use std::ops::Sub;","highlight_start":1,"highlight_end":22},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// #[derive(Debug, PartialEq)]","highlight_start":1,"highlight_end":31},{"text":"// struct Point<T> {","highlight_start":1,"highlight_end":21},{"text":"//     x: T,","highlight_start":1,"highlight_end":13},{"text":"//     y: T,","highlight_start":1,"highlight_end":13},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl <T: Sub<Output = T>> Sub for Point<T> {","highlight_start":1,"highlight_end":48},{"text":"//     type Output = Self;","highlight_start":1,"highlight_end":27},{"text":"//     fn sub(self, other: Self) -> Self::Output {","highlight_start":1,"highlight_end":51},{"text":"//         Point {","highlight_start":1,"highlight_end":19},{"text":"//             x: self.x - other.x,","highlight_start":1,"highlight_end":36},{"text":"//             y: self.y - other.y,","highlight_start":1,"highlight_end":36},{"text":"//         }","highlight_start":1,"highlight_end":13},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     assert_eq!(","highlight_start":1,"highlight_end":19},{"text":"//         Point { x: 2, y: 3 } - Point { x: 1, y: 0 },","highlight_start":1,"highlight_end":56},{"text":"//         Point { x: 1, y: 3 }","highlight_start":1,"highlight_end":32},{"text":"//     );","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// trait UsernameWidget {","highlight_start":1,"highlight_end":26},{"text":"//     // Get the selected username out of this widget","highlight_start":1,"highlight_end":55},{"text":"//     fn get(&self) -> String;","highlight_start":1,"highlight_end":32},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait AgeWidget {","highlight_start":1,"highlight_end":21},{"text":"//     // Get the selected age out of this widget","highlight_start":1,"highlight_end":50},{"text":"//     fn get(&self) -> u8;","highlight_start":1,"highlight_end":28},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // A form with both a UsernameWidget and an AgeWidget.","highlight_start":1,"highlight_end":58},{"text":"// #[derive(Debug)]","highlight_start":1,"highlight_end":20},{"text":"// struct Form {","highlight_start":1,"highlight_end":17},{"text":"//     username: String,","highlight_start":1,"highlight_end":25},{"text":"//     age: u8,","highlight_start":1,"highlight_end":16},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl UsernameWidget for Form {","highlight_start":1,"highlight_end":34},{"text":"//     fn get(&self) -> String {","highlight_start":1,"highlight_end":33},{"text":"//         self.username.clone()","highlight_start":1,"highlight_end":33},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl AgeWidget for Form {","highlight_start":1,"highlight_end":29},{"text":"//     fn get(&self) -> u8 {","highlight_start":1,"highlight_end":29},{"text":"//         self.age","highlight_start":1,"highlight_end":20},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let form = Form{","highlight_start":1,"highlight_end":24},{"text":"//         username: \"rustacean\".to_owned(),","highlight_start":1,"highlight_end":45},{"text":"//         age: 28,","highlight_start":1,"highlight_end":20},{"text":"//     };","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     // If you uncomment this line, you'll get an error saying ","highlight_start":1,"highlight_end":66},{"text":"//     // \"multiple `get` found\". Because, after all, there are multiple methods","highlight_start":1,"highlight_end":81},{"text":"//     // named `get`.","highlight_start":1,"highlight_end":23},{"text":"//     // println!(\"{}\", form.get());","highlight_start":1,"highlight_end":38},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"//     let username = UsernameWidget::get(&form);","highlight_start":1,"highlight_end":50},{"text":"//     println!(\"Value is {}\", username);","highlight_start":1,"highlight_end":42},{"text":"//     assert_eq!(\"rustacean\".to_owned(), username);","highlight_start":1,"highlight_end":53},{"text":"//     let age = AgeWidget::get(&form); // You can also use `<Form as AgeWidget>::get`","highlight_start":1,"highlight_end":87},{"text":"//     assert_eq!(28, age);","highlight_start":1,"highlight_end":28},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// trait Pilot {","highlight_start":1,"highlight_end":17},{"text":"//     fn fly(&self) -> String;","highlight_start":1,"highlight_end":32},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// trait Wizard {","highlight_start":1,"highlight_end":18},{"text":"//     fn fly(&self) -> String;","highlight_start":1,"highlight_end":32},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// struct Human;","highlight_start":1,"highlight_end":17},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Pilot for Human {","highlight_start":1,"highlight_end":26},{"text":"//     fn fly(&self) -> String {","highlight_start":1,"highlight_end":33},{"text":"//         String::from(\"This is your captain speaking.\")","highlight_start":1,"highlight_end":58},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Wizard for Human {","highlight_start":1,"highlight_end":27},{"text":"//     fn fly(&self) -> String {","highlight_start":1,"highlight_end":33},{"text":"//         String::from(\"Up!\")","highlight_start":1,"highlight_end":31},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Human {","highlight_start":1,"highlight_end":16},{"text":"//     fn fly(&self) -> String {","highlight_start":1,"highlight_end":33},{"text":"//         String::from(\"*waving arms furiously*\")","highlight_start":1,"highlight_end":51},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let person = Human;","highlight_start":1,"highlight_end":27},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     assert_eq!(Pilot::fly(&person), \"This is your captain speaking.\");","highlight_start":1,"highlight_end":74},{"text":"//     assert_eq!(Wizard::fly(&person), \"Up!\");","highlight_start":1,"highlight_end":48},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     assert_eq!(person.fly(), \"*waving arms furiously*\");","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"Success!\");","highlight_start":1,"highlight_end":29},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"// trait Person {","highlight_start":1,"highlight_end":18},{"text":"//     fn name(&self) -> String;","highlight_start":1,"highlight_end":33},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait Student: Person {","highlight_start":1,"highlight_end":27},{"text":"//     fn university(&self) -> String;","highlight_start":1,"highlight_end":39},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait Programmer {","highlight_start":1,"highlight_end":22},{"text":"//     fn fav_language(&self) -> String;","highlight_start":1,"highlight_end":41},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// trait CompSciStudent: Programmer + Student {","highlight_start":1,"highlight_end":48},{"text":"//     fn git_username(&self) -> String;","highlight_start":1,"highlight_end":41},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn comp_sci_student_greeting(student: &dyn CompSciStudent) -> String {","highlight_start":1,"highlight_end":74},{"text":"//     format!(","highlight_start":1,"highlight_end":16},{"text":"//         \"My name is {} and I attend {}. My favorite language is {}. My Git username is {}\",","highlight_start":1,"highlight_end":95},{"text":"//         student.name(),","highlight_start":1,"highlight_end":27},{"text":"//         student.university(),","highlight_start":1,"highlight_end":33},{"text":"//         student.fav_language(),","highlight_start":1,"highlight_end":35},{"text":"//         student.git_username()","highlight_start":1,"highlight_end":34},{"text":"//     )","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// struct CSStudent {","highlight_start":1,"highlight_end":22},{"text":"//     name: String,","highlight_start":1,"highlight_end":21},{"text":"//     university: String,","highlight_start":1,"highlight_end":27},{"text":"//     fav_language: String,","highlight_start":1,"highlight_end":29},{"text":"//     git_username: String","highlight_start":1,"highlight_end":28},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl CompSciStudent for CSStudent {","highlight_start":1,"highlight_end":39},{"text":"//     fn git_username(&self) -> String {","highlight_start":1,"highlight_end":42},{"text":"//         self.git_username.clone()","highlight_start":1,"highlight_end":37},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// // Làm tương tự cho các phương thức của trait Person, Student và Programmer","highlight_start":1,"highlight_end":79},{"text":"// impl Person for CSStudent {","highlight_start":1,"highlight_end":31},{"text":"//     fn name(&self) -> String {","highlight_start":1,"highlight_end":34},{"text":"//         self.name.clone()","highlight_start":1,"highlight_end":29},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Student for CSStudent {","highlight_start":1,"highlight_end":32},{"text":"//     fn university(&self) -> String {","highlight_start":1,"highlight_end":40},{"text":"//         self.university.clone()","highlight_start":1,"highlight_end":35},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// impl Programmer for CSStudent {","highlight_start":1,"highlight_end":35},{"text":"//     fn fav_language(&self) -> String {","highlight_start":1,"highlight_end":42},{"text":"//         self.fav_language.clone()","highlight_start":1,"highlight_end":37},{"text":"//     }","highlight_start":1,"highlight_end":9},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// fn main() {","highlight_start":1,"highlight_end":15},{"text":"//     let student = CSStudent {","highlight_start":1,"highlight_end":33},{"text":"//         name: \"Sunfei\".to_string(),","highlight_start":1,"highlight_end":39},{"text":"//         university: \"XXX\".to_string(),","highlight_start":1,"highlight_end":42},{"text":"//         fav_language: \"Rust\".to_string(),","highlight_start":1,"highlight_end":45},{"text":"//         git_username: \"sunface\".to_string()","highlight_start":1,"highlight_end":47},{"text":"//     };","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"//     println!(\"{}\", comp_sci_student_greeting(&student));","highlight_start":1,"highlight_end":60},{"text":"// }","highlight_start":1,"highlight_end":5},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"// =================================================================","highlight_start":1,"highlight_end":69},{"text":"use std::fmt;","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `std::fmt`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:3926:5\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3926\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::fmt;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"1 warning emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 1 warning emitted\u001b[0m\n\n"}
